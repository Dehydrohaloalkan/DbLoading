# 4. Backend (.NET 10) — дизайн

## 4.1. Предлагаемая структура solution/projects

Рекомендуемая структура (один backend‑сервис, без микросервисов):

- `src/DbLoading.Server` — ASP.NET Core host (Controllers, DI, SignalR)
- `src/DbLoading.Application` — use‑cases, оркестрация запусков, планировщик по lanes
- `src/DbLoading.Domain` — модели, статусы, события, observer контракты
- `src/DbLoading.Infrastructure` — DB2 provider (пока заглушка), файловая система, токены, stream (заглушка)

## 4.2. Модель выполнения: Run → Lanes → Scripts → Variants

### Run

Run — атомарный “сеанс” выгрузки:

- `runId` (GUID/ULID)
- пользовательский контекст (login, db, manager, stream)
- snapshot выбора: какие группы/скрипты включены, режимы (Default/Custom)
- список задач (по вариантам)
- агрегированные статусы по Script/Group/Run

### Execution lanes (N потоков SQL)

- `executionLaneCount` задаётся конфигом.
- Для каждого Script задан `executionLane` (0..N-1).
- Внутри lane задачи выполняются **строго последовательно**.
- Lanes работают параллельно между собой.

## 4.3. Выполнение DB2 (пока заглушка)

### Контракт

Интерфейс уровня Application/Domain:

- `IDb2SessionFactory` — создаёт сессию по DB‑контексту (server, database, uid, pwd)
- `IDb2Session` — выполняет SQL и возвращает `IAsyncEnumerable<string>` строк результата

На старте можно реализовать заглушку, которая возвращает фиксированный набор строк, чтобы фронт/пайплайн нарезки можно было развивать независимо от DB2.

### Хранение DB‑учётки

По требованию: DB‑учётные данные хранятся **только в памяти** на сервере:

- При логине backend проверяет соединение и создаёт “session record” (в памяти), привязанный к userId + refresh token sessionId.
- Доступ к выполнению SQL возможен только при наличии валидной сессии.
- При рестарте backend все сессии теряются (пользователь логинится заново).

## 4.4. Модификация SQL (замена SELECT "LineFile")

Требование: исходный SQL начинается с `SELECT "LineFile" ...`.

### Алгоритм (устойчивый к пробелам/переносам)

1. Нормализовать только для поиска (без изменения оригинала):
   - пропустить leading whitespace
2. Проверить, что начало соответствует шаблону:
   - `SELECT` (case‑insensitive)
   - далее whitespace
   - далее `"LineFile"` (в двойных кавычках)
3. Найти позицию конца `"LineFile"` и заменить выражение SELECT‑списка на:
   - DB2 конкатенация: `expr1 || '|' || expr2 || '|' || expr3 ...`
4. При Custom режиме обязательно применить экранирование/NULL‑handling (см. ниже).

Если SQL не соответствует шаблону — вернуть ошибку “script is not modifiable” и пометить Script как `Failed` (или, альтернативно, выполнить Default — решение зафиксировать в конфиге; по умолчанию безопаснее **ошибка**, чтобы не выгружать “не то”).

## 4.5. Формирование строки при Custom columns

### Разделитель

Строго `|`.

### NULL‑handling

Каждое выражение приводится к строке и `NULL` заменяется на пустую строку:

- `COALESCE(CHAR(expr), '')` (пример, точный каст под DB2 уточнить при внедрении)

### Экранирование

Экранируем символы:

- `\` → `\\`
- `|` → `\|`
- `\r` → `\\r`
- `\n` → `\\n`

Важно: даже если “скорее всего их не будет”, фиксируем правила однозначно, чтобы downstream обработка была детерминированной.

Реализация может быть:

- либо на стороне SQL (REPLACE цепочка),
- либо на стороне .NET при чтении строк результата по колонкам (но тогда SQL должен возвращать колонки отдельно, а не одной строкой).

В текущем ТЗ предполагается **замена SELECT на одну строку** (т.е. SQL возвращает 1 колонку), поэтому экранирование проще делать в SQL выражении. Конкретные выражения экранирования зависят от DB2 функций и фиксируются при подключении DB2.

## 4.6. Нарезка файлов по 10 MiB

### Вход

Поток строк `IAsyncEnumerable<string>`, каждая строка уже готова к записи (либо пришла как LineFile, либо сформирована/экранирована).

### Правила

- Кодировка задаётся конфигом (по умолчанию `utf-8`).
- Лимит: `maxFileBytes = 10 * 1024 * 1024`.
- Файл не превышает лимит.
- Строка не разрывается:
  - если строка не влезает — начать новый файл, затем записать строку

### Имена файлов

- `part-0001.txt`, `part-0002.txt`, …
- отдельные папки по группе/скрипту/варианту (см. `09-data-export-pipeline.md`)

## 4.7. Очередь, отмена, повторный запуск

- Start Run:
  - validate config snapshot
  - cleanup output (политика)
  - enqueue jobs в lanes
  - broadcast `Queued` в SignalR
- Cancel:
  - помечает `runId` cancelled
  - worker проверяет cancellation token между чтением строк/пакетами
  - статус `Cancelled`

Повторный запуск — новый `runId`, результаты предыдущего запуска очищаются по политике “перед стартом”.

## 4.8. Observer hooks (точки расширения)

Observer реализуется как publish/subscribe внутри процесса:

- Application вызывает `IExportObserver` события (sync/async)
- можно регистрировать несколько обработчиков через DI

Подробный список событий — `10-observer-events.md`.

