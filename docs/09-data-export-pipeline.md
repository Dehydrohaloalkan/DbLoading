# 9. Пайплайн выгрузки (DB2 → файлы → (stream) → cleanup)

## 9.1. Цель пайплайна

Надёжно выгрузить результат SQL на диск, нарезать на 10 MiB, и (в будущем) записать во внешний поток с гарантированной доставкой.

Ключевой принцип: **сначала диск, потом поток**. Писать напрямую в поток опасно из‑за возможных ошибок DB2.

## 9.2. Структура выходных данных

В `OutputRoot` (из `config/app.json`) создаётся структура:

- `OutputRoot/<runId>/`
  - `<groupId-or-name>/`
    - `<scriptId-or-name>/`
      - `v1/`, `v2/`, `v3/`
        - `part-0001.txt`, `part-0002.txt`, ...

Примечание: пользователь не видит “варианты” в UI, но на диске удобно разделять, чтобы результаты трёх SQL не смешивались.

## 9.3. Очистка

Требование: “лучше чистить старое перед новым запуском, так будет время посмотреть”.

Рекомендуемая политика по умолчанию:

- `BeforeRunIfPreviousSucceeded`
  - перед стартом нового `run` удаляем результаты **предыдущего успешного** run
  - если предыдущий run был `Failed` — не удаляем автоматически

Альтернативы описаны в `06-config-format.md`.

## 9.4. Выполнение (по шагам)

### Шаг A — Планирование задач

1. Backend получает “selection snapshot” от UI.
2. Для каждого включённого логического скрипта:
   - создаёт 3 задачи (варианты v1..v3)
   - назначает в lane по `executionLane`

### Шаг B — Выполнение SQL и запись на диск

Worker lane делает:

1. Читает SQL файл (вариант).
2. Если режим Default:
   - выполняет SQL как есть (получает 1 колонку LineFile как строку).
3. Если режим Custom:
   - модифицирует SQL (замена `SELECT "LineFile"`),
   - выполняет модифицированный SQL (получает 1 колонку).
4. Пишет строки в `part-XXXX.txt`, соблюдая лимит 10 MiB:
   - bytes считаются в выбранной кодировке
   - строка не разрывается
5. Если 0 строк — файлов не создаёт, статус `NoData`.

### Шаг C — (будущее) Stream writer

Отдельный компонент (не входящий в N lanes):

1. Получает список файлов, созданных для варианта.
2. Пишет файл в stream с подтверждением (ack).
3. Только после подтверждения удаляет локальный файл.

До реализации stream — заглушка, которая:

- логирует “would send file X to stream”
- не удаляет файлы

### Шаг D — Завершение run

Run считается завершённым, когда все выбранные скрипты завершились (Success/NoData/Failed/Cancelled) и пост‑обработчики (observer) отработали.

## 9.5. Гарантированная доставка (будущий контракт)

Чтобы обеспечить “exactly once” на стороне stream обычно требуется идемпотентность/ключи.

Рекомендация для design:

- `streamMessageId = <runId>/<groupId>/<scriptId>/<variantId>/<partNumber>`
- stream writer повторяет отправку при ошибке, используя тот же `streamMessageId`
- downstream может дедуплицировать по id

## 9.6. Пустые файлы

Требование: “пустые файлы писать не надо”.

- Если вариант вернул 0 строк → не создавать `part-0001.txt`, статус `NoData`.
- Если вариант вернул строки, но после фильтрации/экранирования они стали пустыми — всё равно строки считаются строками (иначе это может скрыть проблемы). Если нужно иначе — это отдельное правило.

